% rd.m:  Opens a variety of eye-movement data file types.% [out] = rd(in);% 'in' is a data file of one of the formats listed below.% 'out' is a data structure of type 'emData', which can include position data,% saccade,fixation and blink events, and a variety of other values. Type% 'help emData' to (eventually) get the structure's current contents and% organization.%   Either argument is optional. Without an input argument, a GUI will% prompt for a data file to open. Without an output argument, the resulting% emData structure will be created in the base workspace.%% Supported formats:% Internal OMlab:  RTRV (.dat)   ASD (.asd)    LabVIEW (.lab)% Universal(ish):  ACSII (.txt)  Ober2 (.obr)  Raw Binary (.bin)%                  EyeLink (.edf) -- first convert using edf2bin% written by  Jonathan Jacobs%             September 1995 - January 2017  (last mod: 01/27/17)% modified by King Yi, 04/27/11 - Modified code to read in DS and TL%                  (digital stimulus output and laser stim on/off times).% January 2017: Gutted and re-written as a function; to reduce use of global% variables; to use a new data structure (emData) for all eye data; to% import saccade, fix and blink info from EDF2bin files.function out = rd(filename)global  samp_freq enviroGcurdir=pwd; newdata=0; chName='';setroot; cd(matlabroot); cd(findomprefs)try   load enviroG.matcatch   beep   disp('Initializing OMtools environment variable.')   enviroenddoRefix = enviroG(4); doFiltering = enviroG(5); doHeadAdj = enviroG(8);clear rh lh rv lv rt lt st sv ds tl hh hvfilefilter={'*.lab;*.txt;*.bin;*.dat;*.obr;*.asd;*.mat;',...   'lab, txt, bin, dat, obr, asd, mat' };rdpath('r'); % last dir we read a file. if we can't, go to root data dir.if nargin==0   [filename, pathname] = uigetfile(filefilter, 'Load a data file');   if filename == 0      disp( 'Canceled.');      cd(curdir)      return;   endelse   seps=strfind(filename,filesep);   pathname = filename( 1:seps(end) );   filename = filename(seps(end)+1:end);end[shortname,exten] = strtok(filename,'.');exten = exten(2:end);disp( [char(13) 'Loading ' filename] )try   cd(pathname)catch   setroot; datadirend% write the data file's path to 'rdpath.txt'rdpath('w', pwd);if strcmpi(exten, 'MAT')   disp('This is a saved workspace.')   disp('  Do you want to clear the present workspace before')   disp('  loading in this saved workspace (y/n)?')   yorn=lower(input('--> ','s'));   if yorn == 'y'      %       global temp      %       temp = filename;      %       filename = temp;      %       clear global temp      %    end      try         load(filename)      catch         disp('Could not loat the .mat file')      end            return   endend% To properly scale the data, each individual "rd_" module calls 'getbias' and% 'applybias' before 'unfold'ing if needed (obsolete? -- used for old ASL IR glasses)% 'fileformat' is used in 'readbias'switch lower(exten)   case {'asd'}      fileformat = 'asyst';  rd_asd;   case {'bin'}      fileformat = 'binary'; rd_bin;   case {'dat'}      fileformat = 'retrieve'; rd_rtrv;   case {'lab'}      fileformat = 'labview'; rd_labv;   case {'obr'}      fileformat = 'ober2'; rd_ober2;   case {'txt'}      fileformat = 'ascii'; rd_ascii;   case {''}      disp('this file has no extension.  Please add the appropriate')      disp('three-letter extension (e.g. .lab, .obr, .txt, etc.)')      %fileformat = 'unknown';      return   otherwise      disp('This is NOT an ASCII data file,') % Great Galloping Gonads, Batman!      disp('it is not a RETRIEVE file,')      % There's something TERRIBLY      disp('it is not an ober2 file,')        % wrong here.  Panic.      disp('it is not an LabVIEW file,')      disp('it is not a raw binary file,')      disp('and it is not an ASYST file.')      disp('Quite frankly, I am stumped. Please make sure that the')      disp('file name has a known three-letter extension at its end.')      %fileformat = 'unknown';      returnenddisp([fileformat ' file successfully read.']);% 'rd_xxxx' returns adjusted data in 'newdata', channel names in 'chName'chName=char(chName);dat_len = length(newdata);% remove any crosstalkif exist([shortname '.xt'],'file')   [xtfactors, xt_err_flag] = readxtalk(filename);   if ~xt_err_flag      newdata = removextalk(newdata, xtfactors, chName);   endend% look for hh, hv data.  If it exists we need to decide whether or% not to modify the lh, rh, lv, rv data.HHadj = 0; HVadj = 0;if (doHeadAdj)   for h_ind = 1:dat_cols      if strcmpi(chName(h_ind,:), 'hh')         disp( ' ' )         disp('  Horizontal head position data found. ')         disp('  Use it to adjust lh and rh data? (y/n) ')         doHHeadCoil = input( '--> ', 's');         if lower(doHHeadCoil) == 'y'            HHadj = 1;            HHindex = h_ind;         end      elseif strcmpi(chName(h_ind,:), 'hv')         disp( ' ' )         disp('  Vertical head position data found. ')         disp('  Use it to adjust lv and rv data? (y/n) ')         doVHeadCoil = input( '--> ', 's');         if lower(doVHeadCoil) == 'y'            HVadj = 1;            HVindex = h_ind;         end      end   endend %if doHeadAdjdisp('')data = emData;data.start_times = [];data.filename = filename;data.recmeth = rectype;data.comments = comments;data.samp_freq = samp_freq;data.numsamps = dat_len;%look for files from EDF data (sacc, fix, blink, start time)if exist([adjfilename '_start_times.txt'],'file')   data.start_times = load([adjfilename '_start_times.txt']);endif exist([adjfilename '_extras.mat'],'file')   data = parsesaccfile(data);   data = parsefixfile(data);end% do any further post-processingif exist([shortname '.z'],'file') && doRefix, refix(filename); endif exist([shortname '.f'],'file') && doFiltering, dofilt; end% assuming the data are all calibrated by this pointdo_limit = 'y';bad_pts = find(newdata > 50);if size(bad_pts,1) > 100 || size(bad_pts,2) > 100   disp('Lots of position data appears to be greater than 50 deg')   disp('It may be either raw/uncalibrated or very noisy.')   disp('Limit data to 50 deg (y/n)? ')   do_limit = lower(input('--> ','s'));endif strcmpi(do_limit,'y')   newdata = poslimiter(newdata, 50);end% put the scaled data into EM Data structure ("data.____")disp( 'Adding new data to array: ' )for ch_ind = 1:dat_cols   scaled_data = newdata(:,ch_ind);   switch lower(chName(ch_ind,:))      case {'lh'}         if (HHadj==1)            scaled_data = scaled_data - newdata(:, HHindex);         end         disp( [sprintf('\b'), ' lh'] )         data.lh.data = scaled_data;      case {'rh'}         if (HHadj==1)            scaled_data = scaled_data - newdata(:, HHindex);         end         disp( [sprintf('\b'), ' rh'] )         data.rh.data = scaled_data;      case {'lv'}         if (HVadj==1)            scaled_data = scaled_data - newdata(:, HVindex);         end         disp( [sprintf('\b'), ' lv'] )         data.lv.data = scaled_data;      case {'rv'}         if (HVadj==1)            scaled_data = scaled_data - newdata(:, HVindex);         end         disp( [sprintf('\b'), ' rv'] )         data.rv.data = scaled_data;      case {'lt'}         disp( [sprintf('\b'), ' lt'] )         data.lt.data = newdata(:,ch_ind);      case {'rt'}         disp( [sprintf('\b'), ' rt'] )         data.rt.data = newdata(:,ch_ind);      case {'hh'}         disp( [sprintf('\b'), ' hh'] )         data.hh.data = newdata(:,ch_ind);      case {'hv'}         disp( [sprintf('\b'), ' hv'] )         data.hv.data = newdata(:,ch_ind);      case {'st'}         disp( [sprintf('\b'), ' st'] )         data.st.data = newdata(:,ch_ind);      case {'sv'}         disp( [sprintf('\b'), ' sv'] )         data.sv.data = newdata(:,ch_ind);      case {'ds'}         % 'ds' passive D/A Converter Lookup Table (See Hardware Doc for more details)         %  DS Vout (x10)   Deg         %     0.4           15         %     0.8           10         %     1.6            5         %     3.2            0         %     6.4           -5         %    12.8          -10         %    25.6          -15         disp( [sprintf('\b'), ' ds'] )         ds = newdata(:,ch_ind);         d_raw=[0.04 0.08 0.16 0.32 0.64 1.28 2.56]*10;         d_scaled=[15 10 5 0 -5 -10 -15];         ds=interp1(d_raw,d_scaled,ds,'linear','extrap');         data.ds.data = ds;      case {'tl'}         disp( [sprintf('\b'), ' tl'] )         % Invert Galvo Laser on/off state (off = 0, on = 1)         data.tl.data = -newdata(:,ch_ind) + 5;      case {'var'}         %eval( [lower(chName(ch_ind,:)) ' = add_col( '...         %   lower(chName(ch_ind,:)) ', newdata(:,ch_ind), nFiles );'] );         disp(['Unknown channel: ' chName(ch_ind,:) ])   endend %for ch_indrd_dig; % load the digital stimulus file if presentif nargout == 0   sname=lower(shortname);   assignin('base', sname, data)   disp(' ')   disp(['The data have been added to the base workspace as the structure variable ' sname])   disp(['You can type "emd_extract(' sname ')" to access the individual channels.'])   yorn=input('Enter "y" to do that now: ','s');   if strcmpi(yorn,'y')      emd_extract(data)   endelse   out = data;end%disp('Applying standard low-pass filtering and creating velocity arrays')%stdproc
% ebAct3D.m: Called by 'eyeballs3D' to perform all the callback actions%% Written by: Jonathan Jacobs%             March 2002 - January 2005 (last mod: 01/23/05)% Files necessary for proper operation:%   'eyeballs3d', 'ebAct3D.m', 'datscale.m', 'd2pt.m'%   'xyplotsettings.m', 'ebdatacheck.m', 'ebdataload.m'%  2 Dec 02: added 'crossH' variable; allow turning crosshairs on/off %    May 03: added 'XYplotsettings' call%            'play' reads settings from XY plot's axis and applies values%            to XY plot playback% 14 Oct 03: added rubberband zoom%    Jan 05: rewrote movie making code, prefs.  reorganized movie prefs.%            user can now specify QT (if available), AVI, or series of JPEGs% valid commands ('buttName' arg string):%  about, hor_sli, hor_txt, vrt_sli, vrt_txt, tor_sli, tor_txt, eyesfront%  start_txt, start_sli, stop_txt, stop_sli, cur_txt, cur_sli%  f_cur, f_start, f_stop %  xy_setup, play!, hvt_update, color, crosshairs, tormrkr, movieprefs, wf_draw%  resize, load_data, done!function ebAct3D( buttName )global rh lh rv lv rt lt st sv samp_freqcomp=computer;vers=version;if comp(1)=='M' & vers(1)=='5'   moviemode = 'qt';  else   moviemode = 'avi';end% look for the open windowsefig = -1; cfig = -1; wfig = -1; sfig = -1; xyfig = -1;wl = get(0,'Children');for i = 1:length(wl)   if strcmp(get(wl(i),'Name'),'Eye Monitor'),           efig=wl(i);  end   if strcmp(get(wl(i),'Name'),'Eye Monitor Control'),   cfig=wl(i);  end   if strcmp(get(wl(i),'Name'),'Waveform Monitor'),      wfig=wl(i);  end   if strcmp(get(wl(i),'Name'),'Data Scaling & Offset'), sfig=wl(i);  end   if strcmp(get(wl(i),'Name'),'XY Plot settings'),   	xyfig=wl(i); endendif cfig<1, disp('Control Window does not exist. Yikes.'); return; endif wfig<1, disp('Waveform Window does not exist. Yikes.'); return; endif efig<1, disp('Eyeballs Window does not exist. Yikes.'); return; end%if pfig<1, disp('Phase Plane Window does not exist. Yikes.'); return; end% verify that there is good data in memory% should not need this here, once 'ebdataload' is in callback for 'load data' button%[status, datlen, noHOR, noVRT, noTOR, noSTM] = ebdatacheck;%if status==0, break; end% retrieve the handles for the control window objects.  They were declared% in 'eyeballs3D'.cH=get(cfig,'UserData');plotHORh=cH(1);     plotVRTh=cH(2);    plotTORh=cH(3);     cboxOS=cH(4); cboxOD=cH(5);       pauseBH=cH(6);     decimateH=cH(7);    %qtfactorH=cH(8);livemonBH=cH(9);    e_movieBH=cH(10);  wf_movieBH=cH(11);  ewindsizeH=cH(12);hor_sli=cH(13);     vrt_sli=cH(14);    tor_sli=cH(15);hor_txt=cH(16);     vrt_txt=cH(17);    tor_txt=cH(18);start_sli=cH(19);   stop_sli=cH(20);   cur_sli=cH(21);start_txt=cH(22);   stop_txt=cH(23);   cur_txt=cH(24);start_txt2=cH(25);  stop_txt2=cH(26);  cur_txt2=cH(27);movPrefsBH=cH(28);  crossH=cH(29);     plotXYh=cH(30);     xysetBH=cH(31);     stopBH=cH(32);     plotSTMh=cH(33);    rbzoomBH=cH(34);% retrieve the handles for the waveform window objects. They will be all% zeros when initialized in 'eyeballs3D'. Almost immediately after this% initialization, 'ebAct3D('wf_draw')' was called and the handles then have% their proper values.  There is a fine line between tricky and skanky.temp=get(wfig,'UserData');planes=temp{1}; wH=temp{2}; wf_ax_inited=temp{3};wf_axLH=wH(1);  wf_overLH=wH(2);  wf_axLV=wH(3);    wf_overLV=wH(4);wf_axLT=wH(5);  wf_overLT=wH(6);  wf_axRH=wH(7);    wf_overRH=wH(8);wf_axRV=wH(9);  wf_overRV=wH(10); wf_axRT=wH(11);   wf_overRT=wH(12);wf_axXY=wH(13); wf_dataXY=wH(14); wf_overXY=wH(15); temp=get(cboxOS,'UserData');os = temp(1); osSocket = temp(2); osMrkr = temp(3);temp=get(cboxOD,'UserData');od = temp(1); odSocket = temp(2); odMrkr = temp(3);move_os=get(cboxOS,'Value');move_od=get(cboxOD,'Value');hor=get(hor_sli,'Value');vrt=get(vrt_sli,'Value');tor=get(tor_sli,'Value');prev_tor = get(tor_sli,'UserData');% because we could be working with data loaded after the initial% setup of the controls, we must reset the controls' max rangedatlen=length(lh);set(start_sli,'Max', datlen);set(stop_sli, 'Max', datlen);set(cur_sli,  'Max', datlen);startpt=round(get(start_sli,'Value'));if startpt>datlen, startpt=1;      set(start_sli,'Value',startpt); endstoppt=round(get(stop_sli,'Value'));if stoppt>datlen,  stoppt=datlen;  set(stop_sli, 'Value',stoppt);  endcurpt=round(get(cur_sli,'Value'));if curpt>datlen,   curpt=startpt;  set(cur_sli,  'Value',curpt);   endlivemonitor=get(livemonBH,'Value');playstep=fix(str2num(get(decimateH,'String')));fps = samp_freq/playstep;t=(1:length(lh))/samp_freq;% make sure we have the most recent movie making prefsmovtemp=get(movPrefsBH,'UserData');qtcompressor = movtemp{1};   spatialqual  = movtemp{2};makeqtmovie  = movtemp{3};   imageformat  = movtemp{4};movie_speed  = movtemp{5};   make_avi     = movtemp{6};make_stills  = movtemp{7};% Four possible axes to draw: hor, vrt, tor and phase plane (ppl)plotHOR = findstr(planes,'h'); if isempty(plotHOR),plotHOR = 0; endplotVRT = findstr(planes,'v'); if isempty(plotVRT),plotVRT = 0; endplotTOR = findstr(planes,'t'); if isempty(plotTOR),plotTOR = 0; endplotHOR = plotHOR & get(plotHORh,'Value');plotVRT = plotVRT & get(plotVRTh,'Value');plotTOR = plotTOR & get(plotTORh,'Value');plotXY  = get(plotXYh, 'Value');numplanes = sum(plotHOR + plotVRT + plotTOR);num_ax = 2*numplanes;% since XY uses only one axisnumplanes = numplanes + sum(plotXY);if plotXY, num_ax = num_ax+1; end% if the scaling and offset window is open, the offset & scaling% factors will be read directly from its controls.% if it is NOT open, check to see if the wf window has been initialized.% if so, there are previously-set o&s values stored in the axes 'UserData'.% if the window is brand new, then initialize o&s values to 0 & 1.% NOTE: for XY plot, you should leave the data scaling window open to% insure that the O&S values are applied, since the H,V,T axes might% not be displayed, and that is where the O&S values are stored when% the data scaling window is closed.if sfig > 0   % get the o/s control handles   hlist = get(sfig,'UserData');   rh_scaleH=hlist(1);   rv_scaleH=hlist(2);   rt_scaleH=hlist(3);   rh_offsetH=hlist(4);  rv_offsetH=hlist(5);  rt_offsetH=hlist(6);   lh_scaleH=hlist(7);   lv_scaleH=hlist(8);   lt_scaleH=hlist(9);   lh_offsetH=hlist(10); lv_offsetH=hlist(11); lt_offsetH=hlist(12);   	lh_scale=str2num(get(lh_scaleH,'String'));	rh_scale=str2num(get(rh_scaleH,'String'));	lv_scale=str2num(get(lv_scaleH,'String'));	rv_scale=str2num(get(rv_scaleH,'String'));	lt_scale=str2num(get(lt_scaleH,'String'));	rt_scale=str2num(get(rt_scaleH,'String'));	lh_offset=str2num(get(lh_offsetH,'String'));	rh_offset=str2num(get(rh_offsetH,'String'));	lv_offset=str2num(get(lv_offsetH,'String'));	rv_offset=str2num(get(rv_offsetH,'String'));	lt_offset=str2num(get(lt_offsetH,'String'));	rt_offset=str2num(get(rt_offsetH,'String')); elseif wf_ax_inited   if wf_axLH, 		lh_os=get(wf_axLH,'UserData'); rh_os=get(wf_axRH,'UserData');	 else	   lh_os={1,0}; rh_os={1,0};    end   if wf_axLV		lv_os=get(wf_axLV,'UserData'); rv_os=get(wf_axRV,'UserData');	 else	   lv_os={1,0}; rv_os={1,0};    end   if wf_axLT		lt_os=get(wf_axLT,'UserData'); rt_os=get(wf_axRT,'UserData'); 	 else	   lt_os={1,0}; rt_os={1,0};    end   	lh_scale=lh_os{1}; lh_offset=lh_os{2}; lv_scale=lv_os{1}; lv_offset=lv_os{2};	lt_scale=lt_os{1}; lt_offset=lt_os{2}; rh_scale=rh_os{1}; rh_offset=rh_os{2};	rv_scale=rv_os{1}; rv_offset=rv_os{2}; rt_scale=rt_os{1}; rt_offset=rt_os{2}; else   lh_scale=1; lv_scale=1; lt_scale=1; lh_offset=0; lv_offset=0; lt_offset=0;   rh_scale=1; rv_scale=1; rt_scale=1; rh_offset=0; rv_offset=0; rt_offset=0;endlhs = lh*lh_scale + lh_offset; rhs = rh*rh_scale + rh_offset;lvs = lv*lv_scale + lv_offset; rvs = rv*rv_scale + rv_offset;lts = lt*lt_scale + lt_offset; rts = rt*rt_scale + rt_offset;maxLHS=max(lhs(startpt:stoppt)); minLHS=min(lhs(startpt:stoppt));maxLVS=max(lvs(startpt:stoppt)); minLVS=min(lvs(startpt:stoppt));maxLTS=max(lts(startpt:stoppt)); minLTS=min(lts(startpt:stoppt));maxRHS=max(rhs(startpt:stoppt)); minRHS=min(rhs(startpt:stoppt));maxRVS=max(rvs(startpt:stoppt)); minRVS=min(rvs(startpt:stoppt));maxRTS=max(rts(startpt:stoppt)); minRTS=min(rts(startpt:stoppt));%%%%%%%%%%%% now for the individual button callbacks %%%%%%%%%%%%%%%%if strcmp( buttName, 'about')   aboutStr = {'Eyeballs -- Version 2.0,  June 2003';               ' ';               'Written by Jonathan Jacobs, Ph.D. (jxj24@cwru.edu)';               ' ';               'Ocular Motor Neurophysiology Lab (www.OMLAB.org)';               'VA Medical Center, Cleveland, OH';               ' ';               'Dept. of Neurology, School of Medicine';               'Case Western Reserve University';               ' ';               'All rights reserved.  All wrongs reversed.';               '(copyleft) 2002 - 2003';               ' '};   msgbox(aboutStr,'About ''Eyeballs''') elseif strcmp( buttName, 'rbzoom')   if get(gco,'value')==1      set(gco,'String','On')      figure(wfig)      zoom on    else      set(gco,'String','Off')      figure(wfig)      zoom off      % update all the damn sliders and text boxes; make sure all axes are equal      xlims=get(gca,'Xlim')*samp_freq;      set(start_sli,'Value', xlims(1))      ebAct3D('start_sli');      set(stop_sli,'Value', xlims(2))      ebAct3D('stop_sli');   end elseif strcmp( buttName, 'hor_sli')   if move_os, set(osSocket,'View', [hor+90 -vrt]); end           if move_od, set(odSocket,'View', [hor+90 -vrt]); end           set(hor_txt,'String', num2str(hor,3));  % update the horizontal readout. elseif strcmp( buttName, 'hor_txt')   hor = str2num(get(hor_txt,'String'));  % elevation value   if isempty(hor) |abs(hor)>45      hor=round(get(hor_sli,'Value'));      set(hor_txt,'String',num2str(hor,3));   end   set(hor_sli, 'Value', hor);   vrt = str2num(get(vrt_txt,'String'));  % type in a new   if move_os, set(osSocket,'View', [hor+90 -vrt]); end   if move_od, set(odSocket,'View', [hor+90 -vrt]); end elseif strcmp( buttName, 'vrt_sli')   if move_os, set(osSocket,'View', [hor+90 -vrt]); end           if move_od, set(odSocket,'View', [hor+90 -vrt]); end           set(vrt_txt,'String', num2str(vrt,3));  % update the vertical readout. elseif strcmp( buttName, 'vrt_txt')   hor = str2num(get(hor_txt,'String'));  % elevation value   vrt = str2num(get(vrt_txt,'String'));  % type in a new   if isempty(vrt) |abs(vrt)>30      vrt=round(get(vrt_sli,'Value'));      set(vrt_txt,'String',num2str(vrt,3));   end   set(vrt_sli, 'Value', vrt);   if move_os, set(osSocket,'View', [hor+90 -vrt]); end   if move_od, set(odSocket,'View', [hor+90 -vrt]); end elseif strcmp( buttName, 'tor_sli')   if move_os      rotate(os,    [1 0 0], tor-prev_tor);      rotate(osMrkr,[1 0 0], tor-prev_tor);      set(osSocket,'UserData',tor);   end           if move_od      rotate(od,    [1 0 0], tor-prev_tor);      rotate(odMrkr,[1 0 0], tor-prev_tor);      set(odSocket,'UserData',tor);   end           set(tor_sli, 'UserData', tor);           set(tor_txt,'String', num2str(tor,3));  % update the torsion readout. elseif strcmp( buttName, 'tor_txt')   tor = str2num(get(tor_txt,'String'));  % desired torsion value   if isempty(tor) |abs(tor)>45      tor=round(get(tor_sli,'Value'));      set(tor_txt,'String',num2str(tor,3));   end   set(tor_sli, 'Value', tor);   ebAct3D('tor_sli') elseif strcmp( buttName, 'eyesfront')   set(hor_sli,'Value', 0); ebAct3D('hor_sli');   set(vrt_sli,'Value', 0); ebAct3D('vrt_sli');   set(tor_sli,'Value', 0); ebAct3D('tor_sli'); elseif strcmp( buttName, 'start_txt')   startpt = str2num(get(start_txt,'String'));   if isempty(startpt), startpt=round(get(start_sli,'Value')); end   set(start_sli,'Value',startpt);   ebAct3D('start_sli') elseif strcmp( buttName, 'start_sli')   if startpt>=stoppt, startpt=stoppt-1; end   startpt = max(startpt,1);   startpt=fix(startpt);   set(start_sli,'Value',startpt);   set(start_txt,'String', num2str(startpt));   set(start_txt2,'String', num2str(startpt/samp_freq));   curpt = max(startpt,curpt);   ebAct3D('cur_sli')   if plotHOR	   set(wf_axLH,'Xlim',[startpt/samp_freq stoppt/samp_freq])	   set(wf_axRH,'Xlim',[startpt/samp_freq stoppt/samp_freq])	   if minLHS~=maxLHS, set(wf_axLH,'yLim',[minLHS maxLHS]); end	   if minRHS~=maxRHS, set(wf_axRH,'yLim',[minRHS maxRHS]); end	end   if plotVRT	   set(wf_axLV,'Xlim',[startpt/samp_freq stoppt/samp_freq])	   set(wf_axRV,'Xlim',[startpt/samp_freq stoppt/samp_freq])	   if minLVS~=maxLVS, set(wf_axLV,'yLim',[minLVS maxLVS]); end	   if minRVS~=maxRVS, set(wf_axRV,'yLim',[minRVS maxRVS]); end	end   if plotTOR	   set(wf_axLT,'Xlim',[startpt/samp_freq stoppt/samp_freq])	   set(wf_axRT,'Xlim',[startpt/samp_freq stoppt/samp_freq])	   if minLTS~=maxLTS, set(wf_axLT,'yLim',[minLTS maxLTS]); end	   if minRTS~=maxRTS, set(wf_axRT,'yLim',[minRTS maxRTS]); end	end elseif strcmp( buttName, 'stop_txt')   stoppt = str2num(get(stop_txt,'String'));   if isempty(stoppt), stoppt=round(get(stop_sli,'Value')); end   set(stop_sli,'Value',stoppt);   ebAct3D('stop_sli') elseif strcmp( buttName, 'stop_sli')   if stoppt<=startpt, stoppt=startpt+1; end   stoppt=min(stoppt,datlen);   stoppt=round(stoppt);   set(stop_sli,'Value',stoppt);   set(stop_txt,'String', num2str(stoppt));   set(stop_txt2,'String', num2str(stoppt/samp_freq));   curpt = min(stoppt,curpt);   ebAct3D('cur_sli')   if plotHOR	   set(wf_axLH,'Xlim',[startpt/samp_freq stoppt/samp_freq])	   set(wf_axRH,'Xlim',[startpt/samp_freq stoppt/samp_freq])	   if minLHS~=maxLHS, set(wf_axLH,'yLim',[minLHS maxLHS]); end	   if minRHS~=maxRHS, set(wf_axRH,'yLim',[minRHS maxRHS]); end	end   if plotVRT	   set(wf_axLV,'Xlim',[startpt/samp_freq stoppt/samp_freq])	   set(wf_axRV,'Xlim',[startpt/samp_freq stoppt/samp_freq])	   if minLVS~=maxLVS, set(wf_axLV,'yLim',[minLVS maxLVS]); end	   if minRVS~=maxRVS, set(wf_axRV,'yLim',[minRVS maxRVS]); end	end   if plotTOR	   set(wf_axLT,'Xlim',[startpt/samp_freq stoppt/samp_freq])	   set(wf_axRT,'Xlim',[startpt/samp_freq stoppt/samp_freq])	   if minLTS~=maxLTS, set(wf_axLT,'yLim',[minLTS maxLTS]); end	   if minRTS~=maxRTS, set(wf_axRT,'yLim',[minRTS maxRTS]); end	end elseif strcmp( buttName(1:3), 'cur')     %% 'cur_txt', 'cur_sli'   if strcmp( buttName(5:7), 'txt')      curpt = str2num(get(cur_txt,'String'));   end   if isempty(curpt), curpt=round(get(cur_sli,'Value')); end   if curpt<startpt, curpt=startpt; end   if curpt>stoppt,  curpt=stoppt; end   curpt=fix(curpt);   set(cur_sli,'Value', curpt );   set(cur_txt,'String', num2str(curpt));   set(cur_txt2,'String', num2str(curpt/samp_freq));   set(osSocket,'View',[lhs(curpt)+90 -lvs(curpt)]);   set(odSocket,'View',[rhs(curpt)+90 -rvs(curpt)]);   prev_tor(1)=get(osSocket,'UserData');   prev_tor(2)=get(odSocket,'UserData');   rotate( os,[1 0 0],     lts(curpt)-prev_tor(1) );   rotate( od,[1 0 0],     rts(curpt)-prev_tor(2) );   rotate( osMrkr,[1 0 0], lts(curpt)-prev_tor(1) );   rotate( odMrkr,[1 0 0], rts(curpt)-prev_tor(2) );   prev_tor = [lts(curpt) rts(curpt)];   set(osSocket,'UserData',prev_tor(1))   set(odSocket,'UserData',prev_tor(2))   ebAct3D('hvt_update')    elseif strcmp( buttName(1), 'f')   if strcmp( buttName(3:5), 'cur')      new_cur=str2num(get(cur_txt2,'string'))*samp_freq;      set(cur_txt,'String',num2str(new_cur));      ebAct3D('cur_txt')    elseif strcmp( buttName(3:6), 'stop')      new_stop=str2num(get(stop_txt2,'string'))*samp_freq;      set(stop_txt,'String',num2str(new_stop));      ebAct3D('stop_txt')    elseif strcmp( buttName(3:7), 'start')      new_start=str2num(get(start_txt2,'string'))*samp_freq;      set(start_txt,'String',num2str(new_start));      ebAct3D('start_txt')   end elseif strcmp( buttName, 'xy_setup')   xyplotenabled=get(plotXYh,'value');   if xyplotenabled      xyplotsettings('initialize')   end elseif strcmp( buttName, 'play!')   pbH = gco;   if get(pbH,'UserData') == 1      disp('Playback in progress. Please wait.')      return   end   set(pbH,'UserData',1)   % allocate space for the movie(s)   %rect = [245 7 96 96]; capture only OS   make_e_movie=get(e_movieBH,'Value');   if make_e_movie      numframes = length(startpt:playstep:stoppt);      e_movie=moviein(numframes,efig);      j=1;   end   make_wf_movie=get(wf_movieBH,'Value');   if make_wf_movie      numframes = length(startpt:playstep:stoppt);      wf_movie=moviein(numframes,wfig);      k=1;   end   % clear the torsions   prev_tor(1)=get(osSocket,'UserData');   prev_tor(2)=get(odSocket,'UserData');   rotate( os,[1 0 0],     prev_tor(1) );   rotate( od,[1 0 0],     prev_tor(2) );   rotate( osMrkr,[1 0 0], prev_tor(1) );   rotate( odMrkr,[1 0 0], prev_tor(2) );   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   %%%%%%%   start of XY plot setup   %%%%%%%%%%   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   if plotXY      % load the settings from the XYplot axis' 'UserData'  They were stored      % there by the 'Apply' or 'Done' commands in 'xyplotsettings.m'      % if you try to play w/o first initializing the xy settings, the xy init      % window will be called, and nothing can happen until it is dismissed.      xy_val=get(wf_axXY, 'Userdata');		if isempty(xy_val)		   xyplotsettings('initialize')		   uiwait         xy_val=get(wf_axXY, 'Userdata');		end      windowtitle  = xy_val{1};   xdata1       = xy_val{2};		xdata1vel    = xy_val{3};   xdata1acc    = xy_val{4};		xdata1label  = xy_val{5};   xdata1other  = xy_val{6};		ydata1       = xy_val{7};   ydata1vel    = xy_val{8};		ydata1acc    = xy_val{9};   ydata1label  = xy_val{10};  		xdata1other = xy_val{11};   xlowlim      = xy_val{12};		xhighlim     = xy_val{13};  ylowlim      = xy_val{14};      yhighlim     = xy_val{15};  line1color   = xy_val{16};		line1style   = xy_val{17};  head1color   = xy_val{18};		head1symbol  = xy_val{19};  history      = xy_val{20};		samp_or_sec  = xy_val{21};  x_dat_str    = xy_val{22};		y_dat_str    = xy_val{23};		% set the color/style/symbol popup menu string		colorlist = ['r' 'y' 'g' 'b' 'c' 'm' 'w' 'k'];		stylelist = ['-' '--' ':' '-.'];		symbolist = ['o' 's' '^' 'x' '*' 'd' 'h'];      line1colorstr  = colorlist(line1color);      line1stylestr  = stylelist(line1style);      head1colorstr  = colorlist(head1color);      head1symbolstr = symbolist(head1symbol);            % If second word of x_data_str is 'other', the user selected data directly      % from the workspace, and should not be modified, just placed in 'xtemp'.      % Otherwise, use 'eval' to place the actual data into 'xtemp', which will       % be differentiated as needed, and the subarray as selected by the 'start'      % and 'stop' controls will be placed into 'xdata' for playback.      % 	The 's' appended to 'x_chan' turns e.g. 'lh' into 'lhs', which is the      % scaled and offset version of 'lh'.  (Don't do this for 'other' data.)      % Ditto for 'ydata'.       [x_chan, temp] = strtok(x_dat_str,','); x_deriv=temp(2:end);      if strcmp(x_deriv,'other')         % have to pull the same fugly trick as we did in 'xyplotsettings'         %(in the findstr(xybutton,'other') code) to create a temporary global         % variable, both here and in the base workspace, that will allow us to         % access the array specified in the 'other' control.         global ebtempresult         evalin('base','global ebtempresult')			evalin('base',['ebtempresult = ' x_chan ';'])			xtemp = ebtempresult;			clear global ebtempresult       else         eval(['xtemp = ' x_chan 's;'])			if x_deriv(1)=='v'				xtemp=d2pt(xtemp,2);			 elseif x_deriv(1)=='a'				xtemp=d2pt(xtemp,2); xtemp=d2pt(xtemp,2);			end		end	      [y_chan, temp] = strtok(y_dat_str,','); y_deriv=temp(2:end);      if strcmp(y_deriv,'other')         global ebtempresult         evalin('base','global ebtempresult')			evalin('base',['ebtempresult = ' y_chan ';'])			ytemp = ebtempresult;			clear global ebtempresult       else			eval(['ytemp = ' y_chan 's;'])			if y_deriv(1)=='v'				ytemp=d2pt(ytemp,2);			 elseif y_deriv(1)=='a'				ytemp=d2pt(ytemp,2); ytemp=d2pt(ytemp,2);			end		end		history = abs(str2num(history));		if samp_or_sec == 1                       % time		   timeshift = round(history*samp_freq);		 else                                     % samples		   timeshift = round(history);		end		xdata = xtemp(startpt:stoppt);   		ydata = ytemp(startpt:stoppt);   		frontpad = NaN * ones(timeshift,1);		ppdata_x = [frontpad; xdata];		ppdata_y = [frontpad; ydata];      % calculate the x,y axis limits.       xmax=max(xdata); xmin=min(xdata);		ymax=max(ydata); ymin=min(ydata);		xrange = xmax-xmin;		yrange = ymax-ymin;		xmincalc = xmin - 0.1*xrange; xmaxcalc = xmax + 0.1*xrange;		ymincalc = ymin - 0.1*yrange; ymaxcalc = ymax + 0.1*yrange;      % If any of the axis limits fields from xyplotsettings have manual entries      % use those.  Otherwise use the calculated limit(s)		if isempty(str2num(xlowlim)),  xmin=xmincalc; else xmin=str2num(xlowlim);  end		if isempty(str2num(xhighlim)), xmax=xmaxcalc; else xmax=str2num(xhighlim); end		if isempty(str2num(ylowlim)),  ymin=ymincalc; else ymin=str2num(ylowlim);  end		if isempty(str2num(yhighlim)), ymax=ymaxcalc; else ymax=str2num(yhighlim); end      if xmin==xmax,xmin=xmin-eps;xmax=xmax+eps; end      if ymin==ymax,ymin=ymin-eps;ymax=ymax+eps; end		set(wf_axXY,'xlim',[xmin xmax],'ylim',[ymin ymax])				set(wf_dataXY,'Color',line1colorstr, 'LineStyle', line1stylestr)		set(wf_dataXY,'XData',[],'YData',[]) 		set(wf_overXY, 'Color',head1colorstr, 'Marker', head1symbolstr,... 		               'MarkerFaceColor',head1colorstr,'MarkerEdgeColor','w')      set(wf_overXY,'Xdata',[],'Ydata',[]);   		figure(wfig); hold on       	end	   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   %%%%%%%   end of XYplot setup   %%%%%%%%%%%%%   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     t_betw_frames = playstep/samp_freq;   i = startpt;   % this is the animation loop.  it is inherently slow, thanks to the very   % time consuming call to 'drawnow.'  I suspect that there is nothing that   % will ever improve its performance.  best time between frames, even with   % 'live monitor' off is ~0.075 seconds for large eyeballs.     % (measured on dual GHz G4, ML7.01 (R14,SP1), OS X 10.3.7)%profile on   a=1; p=0;   while i <= stoppt      stoppt=round(get(stop_sli,'Value'));  % can stop animation in the middle      tic;      set(osSocket,'View',[lhs(i)+90 -lvs(i)]);      set(odSocket,'View',[rhs(i)+90 -rvs(i)]);      if lts(i)			rotate( os,[1 0 0],     lts(i)-prev_tor(1) );			rotate( osMrkr,[1 0 0], lts(i)-prev_tor(1) );		end		if rts(i)			rotate( od,[1 0 0],     rts(i)-prev_tor(2) );			rotate( odMrkr,[1 0 0], rts(i)-prev_tor(2) );		end		prev_tor = [lts(i) rts(i)];       set(cur_sli,'Value', i);      set(cur_txt,'String', num2str(i));      set(cur_txt2,'String', num2str(i/samp_freq));      % get the frame(s)      if make_e_movie,   e_movie(:,j)=getframe(efig); j=j+1; end      if make_wf_movie, wf_movie(:,k)=getframe(wfig); k=k+1; end      % update the H/V/T sliders, textboxes and the waveform window. (frippery)		% used to be a single call to 'ebAct3D('hvt_update')' but the recursive		% nature of that call adds a lot of extra overhead.  such is life.		i = get(cur_sli,'Value');		if livemonitor		   %set(vrt_sli,'Value', lvs(i));			%set(vrt_txt,'String', num2str(lvs(i),3));			%set(hor_sli,'Value',  lhs(i));			%set(hor_txt,'String', num2str(lhs(i),3));			%set(tor_sli,'Value', lts(i));			%set(tor_sli,'UserData', lts(i));			%set(tor_txt,'String', num2str(lts(i),3));			xval = i/samp_freq;				   		   if plotHOR			   set(wf_overLH,'Xdata',xval);			   set(wf_overLH,'Ydata',lhs(i));			   set(wf_overRH,'Xdata',xval);			   set(wf_overRH,'Ydata',rhs(i));			end		   if plotVRT			   set(wf_overLV,'Xdata',xval);			   set(wf_overLV,'Ydata',lvs(i));			   set(wf_overRV,'Xdata',xval);			   set(wf_overRV,'Ydata',rvs(i));			end		   if plotTOR			   set(wf_overLT,'Xdata',xval);			   set(wf_overLT,'Ydata',lts(i));			   set(wf_overRT,'Xdata',xval);			   set(wf_overRT,'Ydata',rts(i));			end   		   if plotXY		      % we had to tack some NaN data onto the beginning of the		      % array (and shift it) so we can have some history to display.            ind=i-startpt+1;		      set(wf_dataXY,'Xdata',ppdata_x(ind:timeshift+ind));		      set(wf_dataXY,'Ydata',ppdata_y(ind:timeshift+ind));		      set(wf_overXY,'Xdata',ppdata_x(timeshift+ind));		      set(wf_overXY,'Ydata',ppdata_y(timeshift+ind));			end   		end      drawnow      t1(a)=toc; a=a+1;      %t1=toc;      time_to_pause = 1000*(t_betw_frames-t1);  %in milliseconds      if time_to_pause > 0         mypause(time_to_pause)         %p=p+1;      end      i = i + playstep;   end%profile viewer%keyboard   % eyes front, mister!   mypause(150)   set(osSocket,'View',[0+90 0]);   set(odSocket,'View',[0+90 0]);   set(osSocket,'UserData',0);   set(odSocket,'UserData',0);	rotate( os,[1 0 0],     -prev_tor(1) );	rotate( od,[1 0 0],     -prev_tor(2) );	rotate( osMrkr,[1 0 0], -prev_tor(1) );	rotate( odMrkr,[1 0 0], -prev_tor(2) );	drawnow      % clear the wform markers   if plotHOR, set(wf_overLH,'Ydata',NaN); set(wf_overRH,'Ydata',NaN); end   if plotVRT, set(wf_overRV,'Ydata',NaN); set(wf_overLV,'Ydata',NaN); end   if plotTOR, set(wf_overRT,'Ydata',NaN); set(wf_overLT,'Ydata',NaN); end   % reset the H/V/T sliders & text boxes   set(vrt_sli,'value', 0); set(vrt_txt,'String', '0');	set(hor_sli,'value', 0); set(hor_txt,'String', '0');	set(tor_sli,'value', 0); set(tor_txt,'String', '0');   set(tor_sli,'UserData', 0);    % unneeded for 'play'?   	   % playback is over   set(pbH,'UserData',0)	old_dir=pwd;      imageformats = {'jpeg','png','tiff','gif'};   imageformatstr = imageformats{imageformat};   % save the movie(s)   % if neither wf nor eye movies are selected, 'start' remains > 'stop'   start = 2; stop = 1;	if make_e_movie,  start = 1; which_movie{1} =  'e_movie';  end	if make_wf_movie, stop  = 2; which_movie{2} =  'wf_movie'; end	prompt{1} = 'Save the eyeball movie as:';	prompt{2} = 'Save the waveform movie as:';   for m = start:stop  %% if start>stop, nothing is executed	   [fn,pn]=uiputfile('',prompt{m});	   if fn==0, return, end	   [fn, exten] = strtok(fn,'.');	   if pn		   %map=get(wfig,'colormap');		   map = colormap;		   cd(pn)		   switch lower(moviemode(1))		    case 'q'		      moviename = [fn '.mov'];		      eval([ 'qtwrite(' which_movie{m} ', map, moviename, ' ...		                '[fps/movie_speed, qtcompressor, spatialqual])' ]);          otherwise            % save the movie frames as individual images and use QuickTime            % to turn them into a real movie, not this AVI shit.            % First, make sure that we are writing frames to new folder				if make_stills					framefold = [fn '_frames'];					temp = dir; maxnum = 0;					foldname = framefold;  %% our inital & default condition					for i=1:length(temp)						% name already exists?  maybe more than one?  append a number to						% the name e.g. 'test_frames1', ... 'test_frames_10',...						% the created folder name will be one higher than the previous						% highest.  will NOT fill in gaps below highest number						tempname = temp(i).name;						if findstr(tempname, framefold)  % name DOES already exist							% look for appended number							num = str2num(tempname(find(isdigit(tempname))));							if isempty(num), num = 0; end							if num >= maxnum, maxnum = num+1; end							foldname = [framefold num2str(maxnum)];						 						 else  % name DOES NOT exist							 ;  % do nothing						end					end					mkdir(foldname); cd(foldname)						% write the individual frames.  We can use QuickTime Pro's nifty					% "Open Image Sequence..." to make a movie from these frames.						for i=1:numframes						  eval([ 'temp_frame = frame2im(' which_movie{m} '(i));' ]);						  temp_name = ['frame_' num2str(i) '.' imageformatstr];						  imwrite(temp_frame,temp_name, imageformatstr);						end					end            if make_avi		         eval([ 'movie2avi(' which_movie{m} ',fn,''colormap'',map,' ...		                ' ''fps'', fps/movie_speed);' ]);            end		   end           %% switch lower(moviemode(1))		end              %% if pn      cd(old_dir)   end                 %% for m   figure(cfig) elseif strcmp( buttName, 'hvt_update')   i = get(cur_sli,'Value');   if livemonitor	   set(vrt_sli,'Value', lvs(i));	   set(vrt_txt,'String', num2str(lvs(i),3));	   set(hor_sli,'Value',  lhs(i));	   set(hor_txt,'String', num2str(lhs(i),3));	   set(tor_sli,'Value', lts(i));	   set(tor_sli,'UserData', lts(i));	   set(tor_txt,'String', num2str(lts(i),3));		         if plotHOR	      set(wf_overLH,'Xdata',i/samp_freq);	      set(wf_overLH,'Ydata',lhs(i));	      set(wf_overRH,'Xdata',i/samp_freq);	      set(wf_overRH,'Ydata',rhs(i));	   end      if plotVRT	      set(wf_overLV,'Xdata',i/samp_freq);	      set(wf_overLV,'Ydata',lvs(i));	      set(wf_overRV,'Xdata',i/samp_freq);	      set(wf_overRV,'Ydata',rvs(i));	   end      if plotTOR	      set(wf_overLT,'Xdata',i/samp_freq);	      set(wf_overLT,'Ydata',lts(i));	      set(wf_overRT,'Xdata',i/samp_freq);	      set(wf_overRT,'Ydata',rts(i));	   end   	end elseif strcmp( buttName, 'color')	eyeColor = uisetcolor;	if any(eyeColor)         % so we can use values containing zeros		map = ones(64,3);		map(64,:) = [0 0 0];		map(63,:) = eyeColor; map(62,:) = eyeColor;		map(61,:) = eyeColor; map(60,:) = eyeColor;	   set(efig,'Colormap',map);   end    elseif strcmp( buttName, 'crosshairs')   crossHstate = get(crossH,'value');   if crossHstate==0, newVis = 'off'; else newVis = 'on'; end   chLineH = get(crossH,'UserData');   set(chLineH(1),'Visible',newVis);   set(chLineH(2),'Visible',newVis);   set(chLineH(3),'Visible',newVis);   set(chLineH(4),'Visible',newVis);    elseif strcmp( buttName, 'tormrkr')   val = get(gco,'Value');   if val      set(osMrkr,'Visible','on');      set(odMrkr,'Visible','on');      %set(osMrkr,'MarkerEdgeColor',[1 0 0]);      %set(osMrkr,'MarkerFaceColor',[1 0 0]);      %set(odMrkr,'MarkerEdgeColor',[1 0 0]);      %set(odMrkr,'MarkerFaceColor',[1 0 0]);    else      set(osMrkr,'Visible','off');      set(odMrkr,'Visible','off');      %set(odMrkr,'MarkerEdgeColor','None');      %set(osMrkr,'MarkerEdgeColor','None');      %set(odMrkr,'MarkerFaceColor','None');      %set(osMrkr,'MarkerFaceColor','None');   end    elseif strcmp( buttName, 'wf_draw')   % why was 'wf_draw' called? (could be 'plot h/v/t/pp' checkbox   % or could be result of data scaling.  If it is checkbox call   % make sure that at least one checkbox remains checked.   caller=get(gco,'UserData');   value = get(plotVRTh,'value') | get(plotHORh,'value') | ...           get(plotTORh,'value') | get(plotXYh, 'value');      if ~value              % if user is turning off final checkbox      set(gco,'Value',1)  % you can't do that!      return   end      % get the window position.  we only care about the origin.   figure(wfig);   wfigpos = get(wfig,'Position');   % if there is pre-existing user data in the XY plot axis, retain it.   % we will restore it at the end of this section   % is this necessary?  'datscale' stores offset/scale values in the    % H,V,T (L&R) axes user data.  but do we want to save it?  hmmmm.   wf_userD = get(wfig,'UserData');   wH = wf_userD{2}; wf_axXY = wH(13);   xy_ax_userD = [];   if wf_axXY, xy_ax_userD = get(wf_axXY,'UserData'); end      clf      % num_ax, numplanes were calculated at the beginning of ebAct3D	if numplanes == 1	   wfigsize=[300 255];	 elseif numplanes == 2	   wfigsize=[300 507];	 elseif numplanes == 3	   wfigsize=[300 640];	 elseif numplanes == 4	   wfigsize=[300 780];	 else	   return  	end	wfigpos(3:4) = wfigsize;   set(wfig,'Position', wfigpos,'Color',[0.2 0.2 0.2]);      ax_units = 'Normalized';   % 'yorig' is y origin for each axis   % majick numbers -- determined by trial and error.   yorig{7} = [0.87 0.76 0.62 0.51 0.37 0.26 0.04];   yorig{6} = [0.85 0.71 0.52 0.38 0.20 0.06];   yorig{5} = [0.83 0.68 0.48 0.33 0.05];   yorig{4} = [0.77 0.56 0.29 0.08];   yorig{3} = [0.72 0.47 0.07];   yorig{2} = [0.53 0.13];   yorig{1} = [0.15];      % 'ht' is height of each axis; 'ppht' is the height of the pp axis   % majick numbers -- determined by trial and error.   ht{7} = 0.09;  ppht{7} = 0.15;   ht{6} = 0.11;     ht{5} = 0.13;  ppht{5} = 0.20;   ht{4} = 0.18;   ht{3} = 0.22;  ppht{3} = 0.30;   ht{2} = 0.35;                  ppht{1} = 0.75;      xorig = 0.18; wid = 0.74;   plotSTM = get(plotSTMh,'value');   % start drawing the desired axes in the wf window.    sub_p = 1; 	 wf_ax = zeros(3,2);   wf_over = zeros(3,2);   chanstr   = {'rhs', 'lhs'; 'rvs', 'lvs'; 'rts', 'lts'};   titlestr  = {'Horizontal'; 'Vertical'; 'Torsional'};   ylabelstr = {'RH (deg)','LH (deg)';'RV (deg)','LV (deg)';'RT (deg)','LT (deg)'};	minval    = [minRHS minLHS; minRVS minLVS; minRTS minLTS];	maxval    = [maxRHS maxLHS; maxRVS maxLVS; maxRTS maxLTS];	scale     = [rh_scale lh_scale; rv_scale lv_scale; rt_scale lt_scale];	offset    = [rh_offset lh_offset; rv_offset lv_offset; rt_offset lt_offset];		plotAX(1) = plotHOR; plotAX(2) = plotVRT; plotAX(3) = plotTOR;	for x=1:3		if plotAX(x)			wf_ax(x,1) = axes('Position',[xorig yorig{num_ax}(sub_p) wid ht{num_ax}]);			if plotSTM, plot(t,sv,'r'); hold on; end			eval([ 'plot(t,' chanstr{x,1} ',''c''); hold on; axis tight; grid' ]);			title(titlestr{x},  'FontSize',14)			ylabel(ylabelstr{x,1},'FontSize',12)			wf_over(x,1) = plot(NaN, NaN,'wo');			set(wf_over(x,1),'MarkerSize',6,'EraseMode','xor','MarkerFaceColor','r')			if minval(x,1)~=maxval(x,1)			   set(wf_ax(x,1),'yLim',[minval(x,1) maxval(x,1)]);			end			set(wf_ax(x,1),'UserData',{scale(x,1), offset(x,1) });			set(wf_ax(x,1),'xlim',[startpt/samp_freq stoppt/samp_freq])			set(wf_ax(x,1),'xticklabel','')			set(wf_ax(x,1),'Units',ax_units,'Color','k')			sub_p=sub_p+1;				wf_ax(x,2) = axes('Position',[xorig yorig{num_ax}(sub_p) wid ht{num_ax}]);			if plotSTM, plot(t,sv,'r'); hold on; end			eval([ 'plot(t,' chanstr{x,2} ',''y''); hold on; axis tight; grid' ]);			ylabel(ylabelstr{x,2},'FontSize',12)			wf_over(x,2) = plot(NaN, NaN,'wo');			set(wf_over(x,2),'MarkerSize',6,'EraseMode','xor','MarkerFaceColor','r')			if minval(x,2)~=maxval(x,2)			   set(wf_ax(x,2),'yLim',[minval(x,2) maxval(x,2)]);			end			set(wf_ax(x,2),'UserData',{scale(x,2), offset(x,2) });			set(wf_ax(x,2),'xlim',[startpt/samp_freq stoppt/samp_freq])			set(wf_ax(x,2),'Units',ax_units,'Color','k')			sub_p=sub_p+1;		end	end		wf_axRH=wf_ax(1,1);      wf_axRV=wf_ax(2,1);      wf_axRT=wf_ax(3,1);	wf_axLH=wf_ax(1,2);      wf_axLV=wf_ax(2,2);      wf_axLT=wf_ax(3,2);	wf_overRH=wf_over(1,1);  wf_overRV=wf_over(2,1);  wf_overRT=wf_over(3,1); 	wf_overLH=wf_over(1,2);  wf_overLV=wf_over(2,2);  wf_overLT=wf_over(3,2);	   % add the xlabel to the final (non XY) axis   if num_ax>1,xlabel('Time (seconds)','FontSize',12); end   % draw the XY axis   wf_axXY = 0; wf_dataXY = 0; wf_overXY = 0;   if plotXY      % create axis w/appropriate labels      % create empty plot for ppl data to be drawn into      wf_axXY = axes('Position',[xorig yorig{num_ax}(sub_p) wid ppht{num_ax}]);      box; hold on  		wf_dataXY = plot(NaN, NaN, 'g');  		wf_overXY = plot(NaN, NaN, 'wo');		%set(wf_dataXY,'EraseMode','xor') %%%		set(wf_overXY,'MarkerSize',6,'EraseMode','xor','MarkerFaceColor','r')		title('XY plot','FontSize',14)		xlabel('X units','FontSize',12)		ylabel('Y units','FontSize',12)		set(wf_axXY,'Units',ax_units, 'color','k')   end   wH = [wf_axLH wf_overLH wf_axLV wf_overLV wf_axLT wf_overLT,...         wf_axRH wf_overRH wf_axRV wf_overRV wf_axRT wf_overRT,...         wf_axXY wf_dataXY wf_overXY];   set(wfig,'UserData',{planes,wH,1});      % does updated wf window still have XY plot axis? If so, restore old user data.   if wf_axXY, set(wf_axXY,'UserData',xy_ax_userD); end      % if called from 'datscale' make the scaling window the foremost one.   % otherwise bring the controls window to the front   if strcmp(caller,'ds')      figure(sfig)    else      figure(cfig)   end elseif strcmp( buttName, 'resize')	newsize = get(ewindsizeH,'Value');	temp = get(efig,'Position');	% with window resizability enabled, we must add 30 pixels to width	% and 43 pixels to the height.  w/resize off, add 15 & 30, respectively.	% sheesh.	realwidth=temp(3)+30;	realheight=temp(4)+43;	center = [temp(1)+realwidth/2  temp(2)+realheight/4];	% i do not understand these funky y-offsets either. they are empirical.	switch newsize	   case 1, set(efig,'Position',[center-[285+15 132-55]  570 264]);  % large	   case 2, set(efig,'Position',[center-[190+15  88-33]  380 176]);  % medium	   case 3, set(efig,'Position',[center-[143+15  66-22]  286 132]);  % small   end    elseif strcmp( buttName, 'load_data')   % button already called 'ebdataload' which simply contains the name of    % preferred method to load data (first clearing out the previous data).   % Now we verify that it is valid data.  Then must update settings of   % various controls to reflect the properties of the new data.	if noHOR      set(plotHORh,'Enable', 'off');  set(plotHORh,'Value',0)    else      set(plotHORh,'Enable','on')   end	if noVRT      set(plotVRTh,'Enable', 'off');  set(plotVRTh,'Value',0)    else      set(plotVRTh,'Enable','on')   end	if noTOR      set(plotTORh,'Enable', 'off');  set(plotTORh,'Value',0)    else      set(plotTORh,'Enable','on')   end   set(start_sli, 'Max',    datlen)   set(cur_sli,   'Max',    datlen)   set(stop_sli,  'Max',    datlen)   set(stop_sli,  'Value',  datlen)   set(stop_txt,  'String', num2str(datlen))   set(stop_txt2, 'String', num2str(datlen/samp_freq))   ebAct3D('wf_draw')          elseif strcmp( buttName, 'movieprefs')   %create a settings window   [movPrefs] = movieprefs(movPrefsBH,playstep);   set(movPrefsBH,'UserData',movPrefs)    elseif strcmp( buttName, 'done!')   cur_dir=pwd;   %cd(matlabroot)   cd(findomprefs)   efigpos = get(efig,'Position');   cfigpos = get(cfig,'Position');   wfigpos = get(wfig,'Position');   map=get(efig,'Colormap');   eyeColor = map(end-1,:);   efigpopup = get(ewindsizeH,'Value');   % get the latest movie making preferences   movtemp=get(movPrefsBH,'UserData');   qtcompressor = movtemp{1};   spatialqual  = movtemp{2};   makeqtmovie  = movtemp{3};   imageformat  = movtemp{4};   movie_speed  = movtemp{5};   make_avi     = movtemp{6};   make_stills  = movtemp{7};   save ebPrefs.mat eyeColor efigpos cfigpos wfigpos efigpopup ...        qtcompressor spatialqual makeqtmovie imageformat ...        movie_speed make_avi make_stills   eval('cd(cur_dir)','')   uiresume   eval('delete(efig)','')   eval('delete(cfig)','')   eval('delete(wfig)','')   eval('delete(mfig)','')   eval('delete(sfig)','')   eval('delete(xyfig)','')end  % if strcmp( buttName ...%*********************************************************************% movieprefs:  a private function in ebAct3D.% Written by:  Jonathan Jacobs%              April 2002 - January 2005 (last mod: 01/19/05) function [movPrefs] = movieprefs(movPrefsBH,playstep)global samp_freqcfig = -1; mfig = -1;wl = get(0,'Children');for i = 1:length(wl)   if strcmp(get(wl(i),'Name'),'Eye Monitor Control'), cfig=wl(i); end   if strcmp(get(wl(i),'Name'),'Movie Prefs'),         mfig=wl(i); endendcomp=computer;vers=version;if comp(1)=='M' & vers(1)=='5'   qt_available = 'on';   avi_available = 'off';  else   qt_available = 'off';   avi_available = 'on';endif mfig < 0   parent_w_pos = get(cfig,'Position');   mfig_ht = 320;   mfig=figure('Position',[parent_w_pos(1)+180 parent_w_pos(2)-70 280 mfig_ht],...               'Resize','off', 'Menubar', 'None', ...               'Name','Movie Prefs','NumberTitle','off' );   movtemp=get(movPrefsBH,'UserData');   qtcompressor = movtemp{1};   spatialqual  = movtemp{2};   makeqtmovie  = movtemp{3};   imageformat  = movtemp{4};   movie_speed  = movtemp{5};   make_avi     = movtemp{6};   make_stills  = movtemp{7};   ypos = mfig_ht;   % create the controls	uicontrol(mfig, 'Style', 'frame','Units', 'pixels',...	   'BackgroundColor',[0.25 0.25 0.25],'Position', [2 ypos-110 276 96]);	ypos = ypos-40;   makeqtH = uicontrol('Style','checkbox','Units','pixels',...	   'Position',[10 ypos-3 140 25],...	   'Tooltip','Choose the format for image frames',...	   'String','Make a QuickTime movie',...	   'HorizontalAlignment', 'center',...	   'Enable',qt_available,...	   'Value', makeqtmovie,... 	   'Callback',['']);	ypos = ypos-30;	uicontrol(mfig, 'Style', 'text',...	   'Position', [20 ypos 120 20], 'String', 'QT codec');   compressH = uicontrol('Style','popup','Units','pixels',...	   'Position',[145 ypos-3 120 25],...	   'String','video|jpeg|animation',...	   'Tooltip','Choose the QT codec',...	   'Enable',qt_available,...	   'HorizontalAlignment', 'center',...	   'Value', qtcompressor,... 	   'Callback',['']);	ypos = ypos-30;	uicontrol(mfig, 'Style', 'text',...	   'Position', [20 ypos 120 20], 'String', 'Quality');   spatqualH = uicontrol('Style','popup','Units','pixels',...	   'Position',[145 ypos-3 120 25],...	   'String','min|low|normal|high|max|lossless',...	   'Tooltip','Set the spatial quality',...	   'HorizontalAlignment', 'center',...	   'Enable',qt_available,...	   'Value', spatialqual,... 	   'Callback',['']);	uicontrol(mfig, 'Style', 'frame','Units', 'pixels',...	   'BackgroundColor',[0.25 0.25 0.25],'Position', [2 ypos-49 276 35]);	ypos = ypos-40;   makeaviH = uicontrol('Style','checkbox','Units','pixels',...	   'Position',[10 ypos-3 130 25],...	   'Tooltip','Choose the format for image frames',...	   'String','Make an AVI movie',...	   'HorizontalAlignment', 'center',...	   'Enable',avi_available,...	   'Value', make_avi,... 	   'Callback',['']);	uicontrol(mfig, 'Style', 'frame','Units', 'pixels',...	   'BackgroundColor',[0.25 0.25 0.25],'Position', [2 ypos-80 276 66]);	ypos = ypos-40;   makestillsH = uicontrol('Style','checkbox','Units','pixels',...	   'Position',[10 ypos-3 130 25],...	   'Tooltip','Choose the format for image frames',...	   'String','Make a series of images (Use QuickTime Pro to combine)',...	   'HorizontalAlignment', 'center',...	   'Value', make_stills,... 	   'Callback',['']);	ypos = ypos-30;	uicontrol(mfig, 'Style', 'text',...	   'Position', [20 ypos 120 20], 'String', 'Still Image Format');   imageformatH = uicontrol('Style','popup','Units','pixels',...	   'Position',[145 ypos-3 120 25],...	   'String','jpeg|png|tiff|gif',...	   'Tooltip','Choose the format for image frames',...	   'HorizontalAlignment', 'center',...	   'Value', imageformat,... 	   'Callback',['']);	uicontrol(mfig, 'Style', 'frame','Units', 'pixels',...	   'BackgroundColor',[0.25 0.25 0.25],'Position', [2 ypos-80 276 66]);	ypos = ypos-40;	uicontrol(mfig, 'Style', 'text',...	   'Position', [10 ypos 110 20], 'String', 'Movie Speed');	moviespeedH = uicontrol(mfig, 'Style', 'edit',...		'Position', [125 ypos 30 20],...		'BackGroundColor','magenta','ForeGroundColor','white',...		'Tooltip','The movie takes x times as long as real-time',...		'String', num2str(movie_speed), 'Callback', [''] );	ypos = ypos-30;	uicontrol(mfig, 'Style', 'text',...	   'Position', [10 ypos 110 20], 'String', 'Effective FPS');	fpsH = uicontrol(mfig, 'Style', 'text',...		'Position', [125 ypos 30 20],...		'BackGroundColor','magenta','ForeGroundColor','white',...		'Tooltip','The movie takes x times as long as real-time',...		'String', num2str((samp_freq/playstep)*movie_speed), 'Callback', [''] );   doneBH = uicontrol(mfig, 'Style', 'Pushbutton',...      'Position', [220 5 50 20],'UserData',0,...      'Tooltip','Close this window','String', 'Done',...      'Callback', ['uiresume'] ); else   return end% 'uiwait' will cause the function to wait here until a 'uiresume' is% executed. 'uiresume' is therefore the command issued by the 'done' callbackuiwaitqtcompressor = get(compressH,'Value');spatialqual  = get(spatqualH,'Value');makeqtmovie  = get(makeqtH,'Value');imageformat  = get(imageformatH,'Value');movie_speed  = str2num(get(moviespeedH,'String'));make_avi     = get(makeaviH,'Value');make_stills  = get(makestillsH,'Value');movPrefs = {qtcompressor, spatialqual, makeqtmovie, ...              imageformat, movie_speed, make_avi make_stills };set(movPrefsBH,'UserData',movPrefs)              close(mfig)%**************************************************************************% mypause.m: a true pause function for delays under a second% Usage: mypause(delay)% where delay is the desired time in milliseconds% NOTE: accuracy is generally good within about 5 ms% Written by:  Jonathan Jacobs%              October 1999  (last mod: 10/19/99)function mypause(delay)diff = 0;tic;while diff*1000 < (delay-0.25)   diff = toc;end
% nafloop.m: iterative solution of tau matrix for NAFP/NAFPX% Find the tau that results in an NAFPx (extended pos,vel limits)% equivalent to the NAFP obtained for the default pos,vel limit.% Written by:  Jonathan Jacobs%              March 1998 - May 1998 (last mod: 05/01/98)% these are the default lims, tauposD=0.5;velD=4.0;tauD=33.3;% algorithm parameterserrlim=0.0005;iterLim=1000;step=0.05;if ~exist('pos')   pos = [];endif isempty(pos)   disp('You must load a data file, select ONE data trace,')   disp('and calculate its velocity and count the number of')   disp('foveations (try the automatic counting feature in "NFF")')   disp('before you can use "NAFPloop"')   returnendif ~exist('samp_freq')   samp_freq = [];endif isempty(samp_freq)   samp_freq = 0;endif samp_freq == 0   samp_freq = input('Enter the sampling frequency (0 to cancel): ');   if samp_freq==0      disp('Cancelling')      return   endend%numfov = input('Enter the number of foveations (0 to cancel): ');%if numfov==0%   disp('Cancelling')%   return%endnumfov = [];posArray=[0.5 0.75 1.0 1.25 1.5 2.0 2.5 3.0 3.5 4.0 5.0 6.0];velArray=[4.0 5.0 6.0 7.0 8.0 9.0 10.0];% initialize the results matricestauNAFP  = zeros(length(velArray),length(posArray));nafpSoln = zeros(length(velArray),length(posArray));numpIts  = zeros(length(velArray),length(posArray));%get the values we want to match[null1, null2, null4, numfov(1,1), null5, null6]= ...        nff(pos,vel,samp_freq,[posD,velD],'showpv');[nafTgt,nafpTgt,a,b,c,d]=nff(pos,vel,samp_freq,numfov,'naf',[tauD,posD,velD]);tauNAFP(1,1)=33.3;% find the solution for each (pos, vel) combo.for j=1:length(velArray)   velLim=velArray(j);   if j>1      tauInit=tauNAFP(j-1,1);    % starting guess: 0.5deg, previous velocity    else      tauInit=tauD;   end   for i=1:length(posArray)      posLim=posArray(i);      disp( ['VelLim: ' num2str(velLim) ',   PosLim: ' num2str(posLim)])      nafp=0;                     % clear the nafp      if i>1         tau=tauNAFP(j,i-1);      % start from previous solution for this vel       else         tau=tauInit;      end      count=0;inc=0;dec=0;      % before we can look for the NAFX,we need to calculate the number      % of foveations for each (posLim,velLim) combo.      [null1, null2, null4, numfov(j,i), null5, null6]= ...              nff(pos,vel,samp_freq,[posLim,velLim],'showpv');      while abs(nafpTgt-nafp)>errlim & count<iterLim         %disp('trying new tau')         % use six output args to suppress display to screen         [naf,nafp,a,b,c,d]=...                 nff(pos,vel,samp_freq,numfov(j,i),'naf',[tau,posLim,velLim]);         if (nafpTgt-nafp) > errlim            %disp('decrementing tau')            tau=tau-step;            dec=dec+1;          elseif (nafpTgt-nafp) < -errlim            %disp('incrementing tau');            tau=tau+step;            inc=inc+1;          else            %disp('Got it!');         end         count=count+1;         if count>(iterLim-1)            disp('SHIT! couldn''t find the solution!')            % there are many reasons why we don't get a solution            % in this case the step size was just too small            if ~(dec>0 & inc>0)               disp(['Doubling the step size to ' num2str(step*2)])               step=step*2;               count = 0;            end         end      end      % columns: position      % rows: velocity      tauNAFP(j,i)  = tau;      nafpSoln(j,i) = nafp;      numpIts(j,i)  = count;      disp(['   Foveations: ' num2str(numfov(j,i))...            '.      solution took ' num2str(count) ' iterations.'])   end   end% draw a pretty picturefiguresurf(posArray, velArray, tauNAFP)%mesh(posArray, velArray, tauNAFP)title(['Tau for NAFP  (file: ' what_f_array ')'])xlabel('Position Limit')ylabel('Velocity Limit')zlabel('Tau (ms)')rotplot